# -*- coding: utf-8 -*-
"""Loan Approval: Financial Risk Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UkVckrjyIWARaS5g6w_Q0z__dFz_aBvA

## Project Plan

1. Load the data
2. Clean the data
3. Explore the data (Main Question: Which client profile is more likely to have an approved loan)

## Loan Approval: Financial Risk Analysis

### Loading and Previewing the Data

##### Dataset - [Financial Risk for Loan Approval](https://www.kaggle.com/datasets/lorenzozoppelletto/financial-risk-for-loan-approval)
"""

#Loading relevant libraries and the data
import numpy as np
import pandas as pd
import seaborn as sb
import matplotlib.pyplot as plt

#Previewing the top of the dataset

loans_data = pd.read_csv('Loan.csv')
loans_data.head()

#Previewing the bottom of the dataset
loans_data.tail()

"""### Cleaning the data"""

#Checking on the datatype
loans_data.info()

"""1. Application date needs to be changed to data type - datetype

"""

#Checking for missing values
loans_data.isnull().sum()

#Checking for Duplicates
loans_data.duplicated().sum()

# Converting the  ApplicationDate column to datetype
loans_data.ApplicationDate = pd.to_datetime(loans_data.ApplicationDate)

#Checking on the data type of various columns
loans_data.info()

# Columns of interest

# Define the columns you want to keep
columns_ = ['ApplicationDate', 'AnnualIncome', 'CreditScore',
                   'EmploymentStatus', 'LoanAmount', 'SavingsAccountBalance',
                   'TotalAssets', 'TotalLiabilities', 'JobTenure', 'HomeOwnershipStatus', 'LoanApproved']

# Create a new DataFrame with only the specified columns
loans = loans_data[columns_]

# Display the first few rows of the new DataFrame
loans.head()

#Check on Shape
loans.shape

"""### Data Exploration and Visualization"""

#Checking on the data points of interest
loans.columns

"""##### Applications over Time"""

# Extract the year and month from the 'ApplicationDate'
loans['Year'] = loans['ApplicationDate'].dt.year
loans['Month'] = loans['ApplicationDate'].dt.to_period('M')

# Group by year and count applications
applications_per_year = loans.groupby('Year').size()

# Plot the line graph for applications per year
plt.figure(figsize=(8, 5))
sb.lineplot(x=applications_per_year.index, y=applications_per_year.values)
plt.title('Number of Loan Applications per Year')
plt.xlabel('Year')
plt.ylabel('Number of Applications')
plt.xticks(rotation=45)  # Rotate x-axis labels if necessary
plt.show()

"""##### Annual Income"""

##AnnualIncome
#ApplicationDate
#EmploymentStatus
#LoanAmount
#HomeOwnershipStatus
#LoanApproved

# Measures of Central Tendency
mean_ai = round(loans['AnnualIncome'].mean(),2)
median_ai = round(loans['AnnualIncome'].median(),2)
mode_ai = round(loans['AnnualIncome'].mode(),2)
percentile_25_ai = round(loans['AnnualIncome'].quantile(0.25),2)
percentile_75_ai = round(loans['AnnualIncome'].quantile(0.75),2)

# Print the results
print('Mean = '+str(mean_ai))
print('Median = '+str(median_ai))
print('Mode = '+str(mode_ai))
print('percentile_25 = '+str(percentile_25_ai))
print('percentile_75 = '+str(percentile_75_ai))

#Majority of the clients who get their loans approved are at what income level?

# Defining the function that will categorize income levels

def result(AnnualIncome):
  if AnnualIncome <= percentile_25_ai:
    return f'<= {percentile_25_ai}'
  elif AnnualIncome <= mean_ai:
    return f'<= {mean_ai}'
  elif AnnualIncome <= percentile_75_ai:
    return f'<= {percentile_75_ai}'
  else:
    return f'> {percentile_75_ai}'

#Applying the function to our dataset
loans['Income Category'] = loans['AnnualIncome'].apply(result)
loans.head()

#Select unique Income Category
loans['Income Category'].unique()

# Grouping by 'Income Category' and counting the number of people in each category
applicants_by_category = loans.groupby('Income Category').size().sort_values(ascending=False).head()
applicants_by_category

# Create a bar plot using seaborn
plt.figure(figsize=(8, 5))
base_color = sb.color_palette()[0]

# Create a bar plot using seaborn
sb.barplot(x=applicants_by_category.values, y=applicants_by_category.index, color=base_color)

# Add labels and title
plt.xlabel('Number of Applicants')
plt.ylabel('Income Category')
plt.title('Number of Applicants by Income Category')

# Show the plot
plt.show()

"""The majority of the applications are from medium lower earners"""

# Filter the loans where LoanApproved is 1
# loans_approved = [loans['LoanApproved'] == 1]
loans_approved = loans[loans['LoanApproved'] == 1]
#applicants_by_category = loans_approved.groupby('Income Category').size().sort_values(ascending=False).head()

approvedApplicants_by_category = loans_approved.groupby('Income Category').size().sort_values(ascending=False).head()
print(approvedApplicants_by_category)

# Create a bar plot using seaborn
# Create a bar plot using seaborn
sb.barplot(x=approvedApplicants_by_category.values, y=approvedApplicants_by_category.index, color=base_color)

# Add labels and title
plt.xlabel('Number of Approved Applicants')
plt.ylabel('Income Category')
plt.title('Number of Approved Applicants by Income Category')

# Show the plot
plt.show()

"""The category with the list approved applications, are the lower earners; defined as anyone who earns below USD 31,679 per year.

##### Other Varibles
"""

##SavingsAccountBalance
#ApplicationDate
#EmploymentStatus
#LoanAmount
#HomeOwnershipStatus
#LoanApproved

##CreditScore
#ApplicationDate
#EmploymentStatus
#LoanAmount
#HomeOwnershipStatus
#LoanApproved

##TotalAssets to ##TotalLiabilities ##Ratio
#ApplicationDate
#EmploymentStatus
#LoanAmount
#HomeOwnershipStatus
#LoanApproved

##JobTenure
#ApplicationDate
#EmploymentStatus
#LoanAmount
#HomeOwnershipStatus
#LoanApproved





